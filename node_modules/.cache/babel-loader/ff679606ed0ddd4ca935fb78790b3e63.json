{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { getMimeType, isDataUrl, makeDataUrl, resolveUrl } from './util';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"'])([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nexport function toRegex(url) {\n  // eslint-disable-next-line no-useless-escape\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n  const result = [];\n  cssText.replace(URL_REGEX, (raw, quotation, url) => {\n    result.push(url);\n    return raw;\n  });\n  return result.filter(url => !isDataUrl(url));\n}\nexport function embed(cssText, resourceURL, baseURL, options, get) {\n  const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n  return Promise.resolve(resolvedURL).then(url => get ? get(url) : getBlobFromURL(url, options)).then(data => {\n    if (typeof data === 'string') {\n      return makeDataUrl(data, getMimeType(resourceURL));\n    }\n\n    return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);\n  }).then(dataURL => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`)).then(content => content, () => resolvedURL);\n}\n\nfunction filterPreferredFontFormat(str, _ref) {\n  let {\n    preferredFontFormat\n  } = _ref;\n  return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, match => {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const [src,, format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n\n      if (!format) {\n        return '';\n      }\n\n      if (format === preferredFontFormat) {\n        return `src: ${src};`;\n      }\n    }\n  });\n}\n\nexport function shouldEmbed(url) {\n  return url.search(URL_REGEX) !== -1;\n}\nexport function embedResources(cssText, baseUrl, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!shouldEmbed(cssText)) {\n      return Promise.resolve(cssText);\n    }\n\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    return Promise.resolve(filteredCSSText).then(parseURLs).then(urls => urls.reduce((deferred, url) => // eslint-disable-next-line promise/no-nesting\n    deferred.then(css => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}