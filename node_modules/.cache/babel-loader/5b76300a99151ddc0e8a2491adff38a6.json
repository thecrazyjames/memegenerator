{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { cloneNode } from './cloneNode';\nimport { embedImages } from './embedImages';\nimport { applyStyleWithOptions } from './applyStyleWithOptions';\nimport { embedWebFonts, getWebFontCSS } from './embedWebFonts';\nimport { getNodeWidth, getNodeHeight, getPixelRatio, createImage, canvasToBlob, nodeToDataURL } from './util';\n\nfunction getImageSize(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const width = options.width || getNodeWidth(node);\n  const height = options.height || getNodeHeight(node);\n  return {\n    width,\n    height\n  };\n}\n\nexport function toSvg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      width,\n      height\n    } = getImageSize(node, options);\n    return Promise.resolve(node).then(nativeNode => cloneNode(nativeNode, options, true)).then(clonedNode => embedWebFonts(clonedNode, options)).then(clonedNode => embedImages(clonedNode, options)).then(clonedNode => applyStyleWithOptions(clonedNode, options)).then(clonedNode => nodeToDataURL(clonedNode, width, height));\n  });\n}\nconst dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\n\nfunction checkCanvasDimensions(canvas) {\n  if (canvas.width > dimensionCanvasLimit || canvas.height > dimensionCanvasLimit) {\n    if (canvas.width > dimensionCanvasLimit && canvas.height > dimensionCanvasLimit) {\n      if (canvas.width > canvas.height) {\n        canvas.height *= dimensionCanvasLimit / canvas.width;\n        canvas.width = dimensionCanvasLimit;\n      } else {\n        canvas.width *= dimensionCanvasLimit / canvas.height;\n        canvas.height = dimensionCanvasLimit;\n      }\n    } else if (canvas.width > dimensionCanvasLimit) {\n      canvas.height *= dimensionCanvasLimit / canvas.width;\n      canvas.width = dimensionCanvasLimit;\n    } else {\n      canvas.width *= dimensionCanvasLimit / canvas.height;\n      canvas.height = dimensionCanvasLimit;\n    }\n  }\n}\n\nexport function toCanvas(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toSvg(node, options).then(createImage).then(img => {\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      const ratio = options.pixelRatio || getPixelRatio();\n      const {\n        width,\n        height\n      } = getImageSize(node, options);\n      const canvasWidth = options.canvasWidth || width;\n      const canvasHeight = options.canvasHeight || height;\n      canvas.width = canvasWidth * ratio;\n      canvas.height = canvasHeight * ratio;\n\n      if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n      }\n\n      canvas.style.width = `${canvasWidth}`;\n      canvas.style.height = `${canvasHeight}`;\n\n      if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n      }\n\n      context.drawImage(img, 0, 0, canvas.width, canvas.height);\n      return canvas;\n    });\n  });\n}\nexport function toPixelData(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      width,\n      height\n    } = getImageSize(node, options);\n    return toCanvas(node, options).then(canvas => {\n      const ctx = canvas.getContext('2d');\n      return ctx.getImageData(0, 0, width, height).data;\n    });\n  });\n}\nexport function toPng(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toCanvas(node, options).then(canvas => canvas.toDataURL());\n  });\n}\nexport function toJpeg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toCanvas(node, options).then(canvas => canvas.toDataURL('image/jpeg', options.quality || 1));\n  });\n}\nexport function toBlob(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return toCanvas(node, options).then(canvasToBlob);\n  });\n}\nexport function getFontEmbedCSS(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return __awaiter(this, void 0, void 0, function* () {\n    return getWebFontCSS(node, options);\n  });\n}","map":null,"metadata":{},"sourceType":"module"}