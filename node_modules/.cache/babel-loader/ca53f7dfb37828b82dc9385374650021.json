{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nconst cssFetchCache = {};\n\nfunction fetchCSS(url) {\n  const cache = cssFetchCache[url];\n\n  if (cache != null) {\n    return cache;\n  }\n\n  const deferred = window.fetch(url).then(res => ({\n    url,\n    cssText: res.text()\n  }));\n  cssFetchCache[url] = deferred;\n  return deferred;\n}\n\nfunction embedFonts(meta) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return meta.cssText.then(raw => {\n      let cssText = raw;\n      const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n      const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n      const loadFonts = fontLocs.map(location => {\n        let url = location.replace(regexUrl, '$1');\n\n        if (!url.startsWith('https://')) {\n          url = new URL(url, meta.url).href;\n        } // eslint-disable-next-line promise/no-nesting\n\n\n        return window.fetch(url).then(res => res.blob()).then(blob => new Promise((resolve, reject) => {\n          const reader = new FileReader();\n\n          reader.onloadend = () => {\n            // Side Effect\n            cssText = cssText.replace(location, `url(${reader.result})`);\n            resolve([location, reader.result]);\n          };\n\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }));\n      }); // eslint-disable-next-line promise/no-nesting\n\n      return Promise.all(loadFonts).then(() => cssText);\n    });\n  });\n}\n\nfunction parseCSS(source) {\n  if (source == null) {\n    return [];\n  }\n\n  const result = [];\n  const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi; // strip out comments\n\n  let cssText = source.replace(commentsRegex, '');\n  const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi'); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    const matches = keyframesRegex.exec(cssText);\n\n    if (matches === null) {\n      break;\n    }\n\n    result.push(matches[0]);\n  }\n\n  cssText = cssText.replace(keyframesRegex, '');\n  const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi; // to match css & media queries together\n\n  const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' + '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'; // unified regex\n\n  const unifiedRegex = new RegExp(combinedCSSRegex, 'gi'); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let matches = importRegex.exec(cssText);\n\n    if (matches === null) {\n      matches = unifiedRegex.exec(cssText);\n\n      if (matches === null) {\n        break;\n      } else {\n        importRegex.lastIndex = unifiedRegex.lastIndex;\n      }\n    } else {\n      unifiedRegex.lastIndex = importRegex.lastIndex;\n    }\n\n    result.push(matches[0]);\n  }\n\n  return result;\n}\n\nfunction getCSSRules(styleSheets) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const ret = [];\n    const deferreds = []; // First loop inlines imports\n\n    styleSheets.forEach(sheet => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray(sheet.cssRules).forEach((item, index) => {\n            if (item.type === CSSRule.IMPORT_RULE) {\n              let importIndex = index + 1;\n              const url = item.href;\n              const deferred = fetchCSS(url).then(metadata => metadata ? embedFonts(metadata) : '').then(cssText => parseCSS(cssText).forEach(rule => {\n                try {\n                  sheet.insertRule(rule, rule.startsWith('@import') ? importIndex += 1 : sheet.cssRules.length);\n                } catch (error) {\n                  console.error('Error inserting rule from remote css', {\n                    rule,\n                    error\n                  });\n                }\n              })).catch(e => {\n                console.error('Error loading remote css', e.toString());\n              });\n              deferreds.push(deferred);\n            }\n          });\n        } catch (e) {\n          const inline = styleSheets.find(a => a.href == null) || document.styleSheets[0];\n\n          if (sheet.href != null) {\n            deferreds.push(fetchCSS(sheet.href).then(metadata => metadata ? embedFonts(metadata) : '').then(cssText => parseCSS(cssText).forEach(rule => {\n              inline.insertRule(rule, sheet.cssRules.length);\n            })).catch(err => {\n              console.error('Error loading remote stylesheet', err.toString());\n            }));\n          }\n\n          console.error('Error inlining remote css file', e.toString());\n        }\n      }\n    });\n    return Promise.all(deferreds).then(() => {\n      // Second loop parses rules\n      styleSheets.forEach(sheet => {\n        if ('cssRules' in sheet) {\n          try {\n            toArray(sheet.cssRules).forEach(item => {\n              ret.push(item);\n            });\n          } catch (e) {\n            console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n          }\n        }\n      });\n      return ret;\n    });\n  });\n}\n\nfunction getWebFontRules(cssRules) {\n  return cssRules.filter(rule => rule.type === CSSRule.FONT_FACE_RULE).filter(rule => shouldEmbed(rule.style.getPropertyValue('src')));\n}\n\nfunction parseWebFontRules(node) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      if (node.ownerDocument == null) {\n        reject(new Error('Provided element is not within a Document'));\n      }\n\n      resolve(toArray(node.ownerDocument.styleSheets));\n    }).then(styleSheets => getCSSRules(styleSheets)).then(getWebFontRules);\n  });\n}\n\nexport function getWebFontCSS(node, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return parseWebFontRules(node).then(rules => Promise.all(rules.map(rule => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n      return embedResources(rule.cssText, baseUrl, options);\n    }))).then(cssTexts => cssTexts.join('\\n'));\n  });\n}\nexport function embedWebFonts(clonedNode, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return (options.fontEmbedCSS != null ? Promise.resolve(options.fontEmbedCSS) : getWebFontCSS(clonedNode, options)).then(cssText => {\n      const styleNode = document.createElement('style');\n      const sytleContent = document.createTextNode(cssText);\n      styleNode.appendChild(sytleContent);\n\n      if (clonedNode.firstChild) {\n        clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n      } else {\n        clonedNode.appendChild(styleNode);\n      }\n\n      return clonedNode;\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}